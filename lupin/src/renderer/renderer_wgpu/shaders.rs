
////////
// This file was automatically generated by the 'build.rs' program.
// It contains the names and contents of the shader files from the 'src/renderer/renderer_wgpu/shaders/' directory.

static SHADER_NAMES: [&str; 3] = ["base.wgsl", "pathtracer.wgsl", "show_texture.wgsl"];

static SHADER_CONTENTS: [&str; 3] = ["\n// Useful constants\nconst f32_max: f32 = 0x1.fffffep+127;\n\nfn transform_point(p: vec3f, transform: mat4x4f)->vec3f\n{\n    let p_vec4 = vec4f(p, 1.0f);\n    let transformed = transform * p_vec4;\n    return (transformed / transformed.w).xyz;\n}\n\nfn transform_dir(dir: vec3f, transform: mat4x4f)->vec3f\n{\n    let dir_vec4 = vec4f(dir, 0.0f);\n    return (transform * dir_vec4).xyz;\n}\n\nstruct Ray\n{\n    ori: vec3f,\n    dir: vec3f,\n    // Precomputed inverse of the ray direction. Since\n    // floating point division is more expensive than\n    // floating point multiplication, it is (in the context of raytracing)\n    // often faster to precompute the inverse of the ray ahead of time.\n    // On the other hand this is duplicated state that has to be managed\n    inv_dir: vec3f\n}\n\n// From: https://tavianator.com/2011/ray_box.html\n// For misses, t = f32_max\nfn ray_aabb_dst(ray: Ray, aabb_min: vec3f, aabb_max: vec3f)->f32\n{\n    let t_min: vec3f = (aabb_min - 0.001 - ray.ori) * ray.inv_dir;\n    let t_max: vec3f = (aabb_max + 0.001 - ray.ori) * ray.inv_dir;\n    let t1: vec3f = min(t_min, t_max);\n    let t2: vec3f = max(t_min, t_max);\n    let dst_far: f32  = min(min(t2.x, t2.y), t2.z);\n    let dst_near: f32 = max(max(t1.x, t1.y), t1.z);\n\n    let did_hit: bool = dst_far >= dst_near && dst_far > 0.0f;\n    return select(f32_max, dst_near, did_hit);\n}\n\n// From: https://www.shadertoy.com/view/MlGcDz\n// Triangle intersection. Returns { t, u, v }\n// For misses, t = f32_max\nfn ray_tri_dst(ray: Ray, v0: vec3f, v1: vec3f, v2: vec3f)->vec3f\n{\n    let v1v0 = v1 - v0;\n    let v2v0 = v2 - v0;\n    let rov0 = ray.ori - v0;\n\n    // Cramer's rule for solving p(t) = ro+t·rd = p(u,v) = vo + u·(v1-v0) + v·(v2-v1).\n    // The four determinants above have lots of terms in common. Knowing the changing\n    // the order of the columns/rows doesn't change the volume/determinant, and that\n    // the volume is dot(cross(a,b,c)), we can precompute some common terms and reduce\n    // it all to:\n    let n = cross(v1v0, v2v0);\n    let q = cross(rov0, ray.dir);\n    let d = 1.0 / dot(ray.dir, n);\n    let u = d * dot(-q, v2v0);\n    let v = d * dot(q, v1v0);\n    var t = d * dot(-n, rov0);\n\n    if min(u, v) < 0.0 || (u+v) > 1.0 { t = f32_max; }\n    return vec3f(t, u, v);\n}\n", "\n//#include \"base.wgsl\"\n\n// Scene representation\n//@group(0) @binding(0) var models: storage\n\n/*\n@group(0) @binding(0) var output_texture: texture_storage_2d<rgba8unorm, write>;\n@group(0) @binding(1) var<storage, read> verts_pos: array<vec3f>;\n@group(0) @binding(2) var<storage, read> indices: array<u32>;\n@group(0) @binding(3) var<storage, read> bvh_nodes: array<BvhNode>;\n@group(0) @binding(4) var<storage, read> verts: array<Vertex>;\n@group(0) @binding(5) var<uniform> camera_transform: mat4x4f;\n*/\n\n//@group(1) @binding(0) var atlas_1_channel: texture_2d<r8unorm, read>;\n// Like base color\n//@group(1) @binding(2) var atlas_3_channels: texture_2d<rgb8unorm, read>;\n// Like environment maps\n//@group(1) @binding(4) var atlas_hdr_3_channels: texture_2d<rgbf32, read>;\n\nconst f32_max: f32 = 0x1.fffffep+127;\n\n// This doesn't include positions, as that\n// is stored in a separate buffer for locality\nstruct Vertex\n{\n    normal: vec3f,\n    tex_coords: vec2f\n}\n\nstruct PerFrame\n{\n    camera_transform: mat4x3f\n}\n\nstruct Material\n{\n    color_scale: vec3f,\n    alpha_scale: f32,\n    roughness_scale: f32,\n    emission_scale: f32,\n\n    // Textures (base coordinates for atlas lookup)\n    // An out of bounds index will yield the neutral value\n    // for the corresponding texture type\n    color_texture: vec2u,      // 3 channels\n    alpha_texture: vec2u,      // 1 channel\n    roughness_texture: vec2u,  // 1 channel\n    emission_texture: vec2u    // hdr 3 channels\n\n    // We also need some texture wrapping info, i guess.\n    // Stuff like: repeat, clamp, etc.\n}\n\nstruct Ray\n{\n    ori: vec3f,\n    dir: vec3f,\n    inv_dir: vec3f  // Precomputed inverse of the ray direction, for performance\n}\n\nfn transform_point(p: vec3f, transform: mat4x4f)->vec3f\n{\n    let p_vec4 = vec4f(p, 1.0f);\n    let transformed = transform * p_vec4;\n    return (transformed / transformed.w).xyz;\n}\n\nfn transform_dir(dir: vec3f, transform: mat4x4f)->vec3f\n{\n    let dir_vec4 = vec4f(dir, 0.0f);\n    return (transform * dir_vec4).xyz;\n}\n\n// NOTE: The odd ordering of the fields\n// ensures that the struct is 32 bytes wide,\n// given that vec3f has 16-byte padding\nstruct BvhNode\n{\n    aabb_min:  vec3f,\n    // If tri_count is 0, this is first_child\n    // otherwise this is tri_begin\n    tri_begin_or_first_child: u32,\n    aabb_max:  vec3f,\n    tri_count: u32\n\n    // Second child is at index first_child + 1\n}\n\nstruct TlasNode\n{\n    aabb_min: vec3f,\n    aabb_max: vec3f,\n    // If is_leaf is true, this is mesh_instance,\n    // otherwise this is first_child\n    mesh_instance_or_first_child: u32,\n    is_leaf:   u32,  // 32-bit bool\n\n    // Second child is at index first_child + 1\n}\n\nstruct MeshInstance\n{\n    // Transform from world space to model space\n    inverse_transform: mat4x3f,\n    material: Material,\n    bvh_root: u32\n}\n\nstruct Scene\n{\n    env_map: vec2u,\n}\n\n// From: https://tavianator.com/2011/ray_box.html\n// For misses, t = f32_max\nfn ray_aabb_dst(ray: Ray, aabb_min: vec3f, aabb_max: vec3f)->f32\n{\n    let t_min: vec3f = (aabb_min - 0.001 - ray.ori) * ray.inv_dir;\n    let t_max: vec3f = (aabb_max + 0.001 - ray.ori) * ray.inv_dir;\n    let t1: vec3f = min(t_min, t_max);\n    let t2: vec3f = max(t_min, t_max);\n    let dst_far: f32  = min(min(t2.x, t2.y), t2.z);\n    let dst_near: f32 = max(max(t1.x, t1.y), t1.z);\n\n    let did_hit: bool = dst_far >= dst_near && dst_far > 0.0f;\n    return select(f32_max, dst_near, did_hit);\n}\n\n// From: https://www.shadertoy.com/view/MlGcDz\n// Triangle intersection. Returns { t, u, v }\n// For misses, t = f32_max\nfn ray_tri_dst(ray: Ray, v0: vec3f, v1: vec3f, v2: vec3f)->vec3f\n{\n    let v1v0 = v1 - v0;\n    let v2v0 = v2 - v0;\n    let rov0 = ray.ori - v0;\n\n    // Cramer's rule for solving p(t) = ro+t·rd = p(u,v) = vo + u·(v1-v0) + v·(v2-v1).\n    // The four determinants above have lots of terms in common. Knowing the changing\n    // the order of the columns/rows doesn't change the volume/determinant, and that\n    // the volume is dot(cross(a,b,c)), we can precompute some common terms and reduce\n    // it all to:\n    let n = cross(v1v0, v2v0);\n    let q = cross(rov0, ray.dir);\n    let d = 1.0 / dot(ray.dir, n);\n    let u = d * dot(-q, v2v0);\n    let v = d * dot(q, v1v0);\n    var t = d * dot(-n, rov0);\n\n    if min(u, v) < 0.0 || (u+v) > 1.0 { t = f32_max; }\n    return vec3f(t, u, v);\n}\n\nstruct HitInfo\n{\n    dst: f32,\n    normal: vec3f,\n    tex_coords: vec2f\n}\n\n//const MAX_BVH_DEPTH: u32 = 25;\n//const STACK_SIZE: u32 = (MAX_BVH_DEPTH + 1) * 8 * 8;\n//var<workgroup> stack: array<u32, STACK_SIZE>;\n\nfn ray_scene_intersection(local_id: vec3u, ray: Ray)->HitInfo\n{\n    // Comment/Uncomment to test the performance of shared memory\n    // vs local array (registers or global memory)\n    // Shared memory is much faster (on a GTX 1070).\n    //let offset: u32 = 0u;\n    let offset = (local_id.y * 8 + local_id.x) * (MAX_BVH_DEPTH + 1);\n\n    //var stack: array<u32, 26>;\n    var stack_idx: u32 = 2;\n    stack[0 + offset] = 0u;\n    stack[1 + offset] = 0u;\n\n    var num_boxes_hit: i32 = 0;\n\n    // t, u, v\n    var min_hit = vec3f(f32_max, 0.0f, 0.0f);\n    var tri_idx: u32 = 0;\n    while stack_idx > 1\n    {\n        stack_idx--;\n        let node = bvh_nodes[stack[stack_idx + offset]];\n\n        if node.tri_count > 0u  // Leaf node\n        {\n            let tri_begin = node.tri_begin_or_first_child;\n            let tri_count = node.tri_count;\n            for(var i: u32 = tri_begin; i < tri_begin + tri_count; i++)\n            {\n                let v0: vec3f = verts_pos[indices[i*3 + 0]];\n                let v1: vec3f = verts_pos[indices[i*3 + 1]];\n                let v2: vec3f = verts_pos[indices[i*3 + 2]];\n                let hit: vec3f = ray_tri_dst(ray, v0, v1, v2);\n                if hit.x < min_hit.x\n                {\n                    min_hit = hit;\n                    tri_idx = i;\n                }\n            }\n        }\n        else  // Non-leaf node\n        {\n            let left_child  = node.tri_begin_or_first_child;\n            let right_child = left_child + 1;\n            let left_child_node  = bvh_nodes[left_child];\n            let right_child_node = bvh_nodes[right_child];\n\n            let left_dst  = ray_aabb_dst(ray, left_child_node.aabb_min,  left_child_node.aabb_max);\n            let right_dst = ray_aabb_dst(ray, right_child_node.aabb_min, right_child_node.aabb_max);\n\n            // Push children onto the stack\n            // The closest child should be looked at\n            // first. This order is chosen so that it's more\n            // likely that the second child will never need\n            // to be visited in depth.\n\n            let visit_left_first: bool = left_dst <= right_dst;\n            let push_left:  bool = left_dst < min_hit.x;\n            let push_right: bool = right_dst < min_hit.x;\n\n            if visit_left_first\n            {\n                if push_right\n                {\n                    stack[stack_idx + offset] = right_child;\n                    stack_idx++;\n                }\n\n                if push_left\n                {\n                    stack[stack_idx + offset] = left_child;\n                    stack_idx++;\n                }\n            }\n            else\n            {\n                if push_left\n                {\n                    stack[stack_idx + offset] = left_child;\n                    stack_idx++;\n                }\n\n                if push_right\n                {\n                    stack[stack_idx + offset] = right_child;\n                    stack_idx++;\n                }\n            }\n        }\n    }\n\n    var hit_info: HitInfo = HitInfo(min_hit.x, vec3f(0.0f), vec2f(0.0f));\n    if hit_info.dst != f32_max\n    {\n        let vert0: Vertex = verts[indices[tri_idx*3 + 0]];\n        let vert1: Vertex = verts[indices[tri_idx*3 + 1]];\n        let vert2: Vertex = verts[indices[tri_idx*3 + 2]];\n        let u = min_hit.y;\n        let v = min_hit.z;\n        let w = 1.0 - u - v;\n\n        hit_info.normal = vert0.normal*w + vert1.normal*u + vert2.normal*v;\n        hit_info.tex_coords = vert0.tex_coords*w + vert1.tex_coords*u + vert2.tex_coords*v;\n    }\n\n    return hit_info;\n}\n\n@compute\n@workgroup_size(8, 8, 1)\nfn cs_main(@builtin(local_invocation_id) local_id: vec3u, @builtin(global_invocation_id) global_id: vec3<u32>)\n{\n    var color = vec4f(1.0f, 0.0f, 0.0f, 1.0f);\n\n    if global_id.x < output_dim.x && global_id.y < output_dim.y\n    {\n        textureStore(output_texture, global_id.xy, color);\n    }\n\n    /*\n    var frag_coord = vec2f(global_id.xy) + 0.5f;\n    var output_dim = textureDimensions(output_texture).xy;\n    var resolution = vec2f(output_dim.xy);\n\n    var uv = frag_coord / resolution;\n    var coord = 2.0f * uv - 1.0f;\n    coord.y *= -resolution.y / resolution.x;\n\n    var camera_look_at = normalize(vec3(coord, 1.0f));\n\n    var camera_ray = Ray(vec3f(0.0f, 0.0f, 0.0f), camera_look_at, 1.0f / camera_look_at);\n    camera_ray.ori = transform_point(camera_ray.ori, camera_transform);\n    camera_ray.dir = transform_dir(camera_ray.dir, camera_transform);\n    camera_ray.inv_dir = 1.0f / camera_ray.dir;\n\n    var hit = ray_scene_intersection(local_id, camera_ray);\n\n    var color = vec4f(select(vec3f(0.0f), hit.normal, hit.dst != f32_max), 1.0f);\n\n    if global_id.x < output_dim.x && global_id.y < output_dim.y\n    {\n        textureStore(output_texture, global_id.xy, color);\n    }\n    */\n}\n", "\r\n@group(0) @binding(0) var to_show: texture_2d<f32>;\r\n@group(0) @binding(1) var tex_sampler: sampler;\r\n@group(0) @binding(2) var<uniform> res: vec2u;\r\n\r\nstruct VertexOutput\r\n{\r\n    @builtin(position) pos: vec4f,\r\n    @location(0) tex_coords: vec2f\r\n}\r\n\r\n@vertex\r\nfn vs_main(@builtin(vertex_index) vert_idx: u32)->VertexOutput\r\n{\r\n    var pos = array<vec2f, 6>\r\n    (\r\n        vec2f(-1.0, -1.0),\r\n        vec2f(-1.0, 1.0),\r\n        vec2f(1.0, -1.0),\r\n        vec2f(1.0, -1.0),\r\n        vec2f(-1.0, 1.0),\r\n        vec2f(1.0, 1.0)\r\n    );\r\n\r\n    return VertexOutput(vec4f(pos[vert_idx], 0.0f, 1.0f), pos[vert_idx] * -0.5f + 0.5f);\r\n}\r\n\r\n@fragment\r\nfn fs_main(@location(0) tex_coords: vec2f)->@location(0) vec4f\r\n{\r\n    var texture_size: vec2u = textureDimensions(to_show).xy;\r\n    let image_aspect_ratio: f32 = f32(texture_size.x) / f32(texture_size.y);\r\n    let screen_aspect_ratio: f32 = f32(res.x) / f32(res.y);\r\n\r\n    // Scale UVs so that it fits the screen while keeping\r\n    // original aspect ratio.\r\n    var texture_scale  = vec2f(1.0f);\r\n    var texture_offset = vec2f(0.0f);\r\n    if screen_aspect_ratio > image_aspect_ratio\r\n    {\r\n        // Vertical bars\r\n        texture_scale = vec2f(screen_aspect_ratio / image_aspect_ratio, 1.0f);\r\n    }\r\n    else\r\n    {\r\n        // Horizontal bars\r\n        texture_scale = vec2f(1.0f, image_aspect_ratio / screen_aspect_ratio);\r\n    }\r\n    \r\n    let texture_coord = (tex_coords - 0.5f) * texture_scale + 0.5f;\r\n\r\n    if (texture_coord.x < 0.0 || texture_coord.x > 1.0 ||\r\n        texture_coord.y < 0.0 || texture_coord.y > 1.0)\r\n    {\r\n        return vec4f(0.0f, 0.0f, 0.0f, 1.0f);\r\n    }\r\n\r\n    return textureSample(to_show, tex_sampler, texture_coord);\r\n}\r\n"];
